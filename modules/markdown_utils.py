import json
import re
import logging
import markdown
import tempfile
import os
from typing import Dict, Any

# Configure logging
# Consider using a shared logger configuration later
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] - %(message)s')
logger = logging.getLogger(__name__)

def plan_to_markdown(plan: Dict[str, Any]) -> str:
    """
    Converts an article plan dictionary into a Markdown string representation.

    Args:
        plan: The plan dictionary, expected to follow the structure generated by ContentEngine.

    Returns:
        A string containing the plan formatted in Markdown.
    """
    try:
        # Basic validation
        if not isinstance(plan, dict):
            logger.error("Invalid plan format: Expected dict.")
            return "Error: Invalid plan format provided."

        markdown_content = []

        # Title and Meta
        keyword = plan.get("keyword", "N/A")
        h1 = plan.get("h1", f"Plan pour {keyword}")
        markdown_content.append(f"# {h1}\n")
        if plan.get("metatitle"):
            markdown_content.append(f"**Meta Title:** {plan['metatitle']}\n")
        if plan.get("metadescription"):
            markdown_content.append(f"**Meta Description:** {plan['metadescription']}\n")

        # Backstory/Brief
        if plan.get("backstory"):
            markdown_content.append(f"## Briefing / Contexte\n\n{plan['backstory']}\n")

        # Data Section
        data = plan.get("data", {})
        if data:
            markdown_content.append("## Données Clés\n")
            if data.get("stats"):
                markdown_content.append("### Statistiques\n" + "\n".join(f"- {s}" for s in data["stats"]) + "\n")
            if data.get("trends"):
                markdown_content.append("### Tendances\n" + "\n".join(f"- {t}" for t in data["trends"]) + "\n")
            if data.get("secondary_keywords"):
                markdown_content.append("### Mots-clés Secondaires\n" + "\n".join(f"- {k}" for k in data["secondary_keywords"]) + "\n")
            if data.get("optimal_content_length"):
                markdown_content.append(f"**Longueur Optimale:** {data['optimal_content_length']}\n")
            if data.get("key_insights"):
                markdown_content.append("### Aperçus Clés\n" + "\n".join(f"- {i}" for i in data["key_insights"]) + "\n")

        # Plan Structure
        plan_sections = plan.get("plan", [])
        if plan_sections:
            markdown_content.append("## Structure Proposée\n")
            for i, section in enumerate(plan_sections):
                h2 = section.get("h2", f"Section {i+1}")
                markdown_content.append(f"### {h2}\n")
                if section.get("h3"):
                    markdown_content.append("Sous-sections (H3):\n" + "\n".join(f"- {h3}" for h3 in section["h3"]) + "\n")
                if section.get("brief"):
                     markdown_content.append(f"**Brief Section:** {section['brief']}\n")
                markdown_content.append("") # Add spacing

        # Include raw SERP data if present (for reference)
        # This might make the Markdown very long, consider if it's always needed here.
        # if plan.get("serp_data"):
        #     markdown_content.append("## Données SERP Brutes (Référence)\n")
        #     markdown_content.append("```json\n" + json.dumps(plan["serp_data"], indent=2, ensure_ascii=False) + "\n```\n")

        return "\n".join(markdown_content)

    except Exception as e:
        logger.error(f"Error converting plan to Markdown: {e}")
        return f"Error converting plan to Markdown: {e}"


def markdown_to_html(md_content: str) -> str:
    """
    Converts Markdown content to HTML using the python-markdown library.

    Args:
        md_content: The Markdown content as a string.

    Returns:
        The converted HTML content as a string, including basic styling.
    """
    try:
        html = markdown.markdown(
            md_content,
            extensions=['extra', 'toc', 'smarty', 'codehilite', 'tables'] # Ensure tables extension is enabled
        )

        # Basic CSS for readability
        styled_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }}
                h1, h2, h3 {{ color: #333; margin-top: 1.5em; }}
                h1 {{ border-bottom: 1px solid #eee; padding-bottom: 0.3em; }}
                a {{ color: #007bff; text-decoration: none; }}
                a:hover {{ text-decoration: underline; }}
                pre, code {{ background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 3px; padding: 0.1em 0.3em; font-family: monospace; }}
                pre {{ padding: 1em; overflow: auto; }}
                blockquote {{ border-left: 3px solid #eee; padding-left: 1em; color: #666; margin-left: 0; }}
                table {{ border-collapse: collapse; width: 100%; margin-bottom: 1em; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                img {{ max-width: 100%; height: auto; }}
            </style>
        </head>
        <body>
            {html}
        </body>
        </html>
        """
        return styled_html
    except Exception as e:
        logger.error(f"Error converting Markdown to HTML: {e}")
        return f"<p>Error converting Markdown to HTML: {e}</p>"


def markdown_to_docx(md_content: str, title: str = "Document") -> bytes:
    """
    Converts Markdown content to a DOCX file using pandoc (preferred) or python-docx as fallback.

    Args:
        md_content: The Markdown content as a string.
        title: The title to embed in the document metadata.

    Returns:
        The DOCX document content as bytes.

    Raises:
        ValueError: If conversion fails with both methods or dependencies are missing.
        FileNotFoundError: If pandoc executable is not found.
        subprocess.CalledProcessError: If pandoc command fails.
    """
    # Attempt 1: Use pandoc (more robust conversion)
    try:
        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False, encoding='utf-8') as md_file:
            md_file.write(md_content)
            md_file_path = md_file.name

        docx_file_path = f"{md_file_path}.docx"

        import subprocess
        logger.info("Attempting Markdown to DOCX conversion using pandoc...")
        process = subprocess.run(
            ["pandoc", md_file_path, "-o", docx_file_path, "--metadata", f"title={title}"],
            capture_output=True,
            text=True,
            check=True, # Raise error if pandoc fails
            encoding='utf-8'
        )
        logger.info("Pandoc conversion successful.")

        with open(docx_file_path, "rb") as docx_file:
            docx_bytes = docx_file.read()

        os.remove(md_file_path)
        os.remove(docx_file_path)
        return docx_bytes

    except FileNotFoundError:
        logger.warning("pandoc command not found. Falling back to python-docx.")
    except subprocess.CalledProcessError as e:
        logger.warning(f"pandoc conversion failed: {e.stderr}. Falling back to python-docx.")
    except Exception as e:
        logger.warning(f"Error during pandoc conversion: {e}. Falling back to python-docx.")

    # Attempt 2: Fallback using python-docx (basic conversion)
    try:
        logger.info("Attempting Markdown to DOCX conversion using python-docx...")
        from docx import Document
        # Note: python-docx does not directly parse Markdown.
        # This will be a very basic conversion, treating paragraphs literally.
        # For better results, consider libraries like 'markdown-docx' if available,
        # or pre-converting MD to HTML and then HTML to DOCX.

        doc = Document()
        doc.add_heading(title, level=0)

        # Simple paragraph-based conversion (doesn't handle lists, bold, etc.)
        for paragraph_text in md_content.split('\n\n'):
             # Basic heading detection
             stripped_p = paragraph_text.strip()
             if stripped_p.startswith('# '):
                 doc.add_heading(stripped_p[2:], level=1)
             elif stripped_p.startswith('## '):
                 doc.add_heading(stripped_p[3:], level=2)
             elif stripped_p.startswith('### '):
                 doc.add_heading(stripped_p[4:], level=3)
             # TODO: Add basic list/bold/italic handling if needed, though complex
             else:
                 doc.add_paragraph(paragraph_text)

        with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as temp_file:
            doc.save(temp_file.name)
            temp_file_path = temp_file.name

        with open(temp_file_path, 'rb') as file:
            docx_bytes = file.read()

        os.remove(temp_file_path)
        logger.info("python-docx conversion fallback completed (basic).")
        return docx_bytes

    except ImportError:
        logger.error("python-docx library not found. Cannot perform fallback conversion.")
        raise ValueError("DOCX conversion failed: pandoc not found or failed, and python-docx is not installed.")
    except Exception as inner_e:
        logger.error(f"python-docx fallback conversion failed: {inner_e}")
        raise ValueError(f"DOCX conversion failed with both pandoc and python-docx: {inner_e}")


def prepare_for_wordpress(md_content: str, title: str = "Article") -> str:
    """
    Converts Markdown content to HTML suitable for the WordPress block editor.

    Args:
        md_content: The Markdown content as a string.
        title: The article title (used for the main H1 block).

    Returns:
        HTML content formatted with WordPress block comments.
    """
    try:
        # Convert base Markdown to HTML first
        html = markdown.markdown(
            md_content,
            extensions=['extra', 'smarty', 'codehilite', 'tables'] # Common extensions
        )

        # --- WordPress Block Conversion ---
        # Order matters here - process more specific blocks first

        # 1. Code Blocks
        html = re.sub(
            r'<pre><code(?: class="language-(.*?)")?>(.*?)</code></pre>',
            r'<!-- wp:code {"language":"\1"} -->\n<pre class="wp-block-code"><code>\2</code></pre>\n<!-- /wp:code -->',
            html,
            flags=re.DOTALL
        )
        # Handle code blocks without language class
        html = re.sub(
            r'<pre><code>(.*?)</code></pre>',
            r'<!-- wp:code -->\n<pre class="wp-block-code"><code>\1</code></pre>\n<!-- /wp:code -->',
            html,
            flags=re.DOTALL
        )


        # 2. Headings (H1 to H6)
        for i in range(6, 0, -1): # Process H6 down to H1
             html = re.sub(
                 rf'<h{i}>(.*?)</h{i}>',
                 rf'<!-- wp:heading {{"level":{i}}} -->\n<h{i}>\1</h{i}>\n<!-- /wp:heading -->',
                 html,
                 flags=re.DOTALL
             )

        # 3. Blockquotes
        html = re.sub(
            r'<blockquote>\s*<p>(.*?)</p>\s*</blockquote>', # Handle paragraph inside blockquote
            r'<!-- wp:quote -->\n<blockquote class="wp-block-quote"><p>\1</p></blockquote>\n<!-- /wp:quote -->',
            html,
            flags=re.DOTALL
        )
        html = re.sub(
            r'<blockquote>(.*?)</blockquote>', # Handle direct content
            r'<!-- wp:quote -->\n<blockquote class="wp-block-quote">\1</blockquote>\n<!-- /wp:quote -->',
            html,
            flags=re.DOTALL
        )


        # 4. Lists (Unordered and Ordered)
        html = re.sub(
            r'<ul>(.*?)</ul>',
            r'<!-- wp:list -->\n<ul>\1</ul>\n<!-- /wp:list -->',
            html,
            flags=re.DOTALL
        )
        html = re.sub(
            r'<ol>(.*?)</ol>',
            r'<!-- wp:list {"ordered":true} -->\n<ol>\1</ol>\n<!-- /wp:list -->',
            html,
            flags=re.DOTALL
        )
        # List items (li) are usually handled correctly within the ul/ol blocks

        # 5. Tables (Basic conversion - WP might need more complex blocks for advanced tables)
        html = re.sub(
            r'<table>',
            r'<!-- wp:table -->\n<figure class="wp-block-table"><table>',
            html
        )
        html = re.sub(
            r'</table>',
            r'</table></figure>\n<!-- /wp:table -->',
            html
        )

        # 6. Paragraphs (Process last as it's the most general)
        # Avoid wrapping existing blocks
        # This regex is tricky; might need refinement. A simpler approach might be needed.
        # Let's try wrapping only paragraphs that are not already inside another block comment.
        # This is hard with regex alone. A simpler approach: wrap all <p> tags.
        # WordPress often handles unwrapped text by putting it in paragraphs anyway.
        # Let's stick to wrapping standard <p> tags for now.
        html = re.sub(
            r'<p>(.*?)</p>',
            r'<!-- wp:paragraph -->\n<p>\1</p>\n<!-- /wp:paragraph -->',
            html,
            flags=re.DOTALL
        )

        # Add the title as the first H1 block if provided
        # wp_title_block = f'<!-- wp:heading {{"level":1}} -->\n<h1>{title}</h1>\n<!-- /wp:heading -->\n\n' if title else ""
        # Prepending title might interfere if the MD already has an H1. Let's assume the MD provides the title structure.

        # Clean up potential double newlines introduced by replacements
        html = re.sub(r'\n\s*\n', '\n\n', html)

        return html.strip()

    except Exception as e:
        logger.error(f"Error preparing content for WordPress: {e}")
        # Fallback to basic HTML conversion if WP formatting fails
        return markdown_to_html(md_content)
